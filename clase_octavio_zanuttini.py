# -*- coding: utf-8 -*-
"""Clase Octavio Zanuttini

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uZ71c7rJ_I6bg0ulLGFPtq1Ik77pUFOX
"""

from sklearn.metrics import auc
from scipy.stats import expon, t, chi2, uniform, norm
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import random
from math import pi
import statsmodels.api as sm
from scipy import stats

class Estimacion:
    def __init__(self, muestra):
        self.muestra = muestra

    def crear_histograma(self, ancho_banda):
        intervalos = np.arange(np.min(self.muestra) - ancho_banda,
                             np.max(self.muestra) + ancho_banda,
                             ancho_banda)
        frecuencias = np.zeros(len(intervalos) - 1)

        for valor in self.muestra:
            for i_intervalo in range(len(intervalos) - 1):
                if intervalos[i_intervalo] <= valor < intervalos[i_intervalo + 1]:
                    frecuencias[i_intervalo] += 1
                    break

        densidad_hist = frecuencias / (len(self.muestra) * ancho_banda)
        return intervalos, densidad_hist

    def evaluar_histograma(self, puntos_x, ancho_banda):
        intervalos, densidad_hist = self.crear_histograma(ancho_banda)
        estimaciones = np.zeros(len(puntos_x))

        for i, x in enumerate(puntos_x):
            for j in range(len(intervalos) - 1):
                if intervalos[j] <= x < intervalos[j + 1]:
                    estimaciones[i] = densidad_hist[j]
                    break
        return estimaciones

    def nucleo_gauss(self, z):
        return (1 / np.sqrt(2 * pi)) * np.exp(-0.5 * z**2)

    def nucleo_rectangular(self, z):
        resultado = np.zeros_like(z)
        for k in range(len(z)):
            if abs(z[k]) <= 1:
                resultado[k] = 0.5
        return resultado

    def nucleo_epanech(self, z):
        resultado = np.zeros_like(z)
        for k in range(len(z)):
            if abs(z[k]) <= 1:
                resultado[k] = 0.75 * (1 - z[k]**2)
        return resultado

    def nucleo_triang(self, z):
        resultado = np.zeros_like(z)
        for k in range(len(z)):
            if abs(z[k]) <= 1:
                resultado[k] = 1 - abs(z[k])
        return resultado

    def estimar_densidad(self, puntos_eval, ancho_banda, tipo_nucleo='rectangular'):
        densidad = []

        for x in puntos_eval:
            u = (self.muestra - x) / (ancho_banda + 1e-10)

            if tipo_nucleo == 'rectangular':
                valores_nucleo = self.nucleo_rectangular(u)
            elif tipo_nucleo == 'gauss':
                valores_nucleo = self.nucleo_gauss(u)
            elif tipo_nucleo == 'epanech':
                valores_nucleo = self.nucleo_epanech(u)
            elif tipo_nucleo == 'triangular':
                valores_nucleo = self.nucleo_triang(u)
            else:
                raise ValueError(f"Núcleo '{tipo_nucleo}' no soportado")

            densidad.append(np.sum(valores_nucleo) / (len(self.muestra) * (ancho_banda + 1e-10)))

        return np.array(densidad)


class AnalisisDescriptivo(Estimacion):
    def __init__(self, datos):
        super().__init__(datos)
        self.datos = np.array(datos)
        self.tamano_muestra = len(self.datos)
        self.resumen = self.calcular_resumen()

    def calcular_promedio(self):
        return np.mean(self.datos)

    def calcular_mediana(self):
        return np.median(self.datos)

    def calcular_desviacion(self):
        return np.std(self.datos, ddof=1)

    def calcular_varianza(self):
        return np.var(self.datos, ddof=1)

    def obtener_cuartiles(self):
        return np.percentile(self.datos, [25, 50, 75])

    def calcular_resumen(self):
        return {
            'Promedio': self.calcular_promedio(),
            'Mediana': self.calcular_mediana(),
            'Desviación': self.calcular_desviacion(),
            'Varianza': self.calcular_varianza(),
            'Cuartiles': self.obtener_cuartiles(),
            'Mínimo': np.min(self.datos),
            'Máximo': np.max(self.datos)
        }

    def grafico_qq(self):
        promedio = self.calcular_promedio()
        desviacion = self.calcular_desviacion()
        datos_estandar = (self.datos - promedio) / desviacion
        cuantiles_muestra = np.sort(datos_estandar)

        probabilidades = np.arange(1, (self.tamano_muestra + 1)) / (self.tamano_muestra + 1)
        cuantiles_teoria = norm.ppf(probabilidades)

        plt.scatter(cuantiles_teoria, cuantiles_muestra, color='green', marker='x')
        plt.xlabel('Cuantiles teóricos')
        plt.ylabel('Cuantiles muestrales')
        plt.plot(cuantiles_teoria, cuantiles_teoria, linestyle='--', color='orange')
        plt.title('Gráfico Q-Q')
        plt.grid(True)
        plt.show()

    def visualizar_histograma(self, ancho):
        x = np.linspace(np.min(self.datos), np.max(self.datos), 200)
        y = self.evaluar_histograma(x, ancho)

        plt.plot(x, y, color='navy', linewidth=2, label='Estimación Histograma')
        plt.title('Estimación de densidad mediante histograma')
        plt.xlabel('Valores')
        plt.ylabel('Densidad')
        plt.legend()
        plt.grid(True)
        plt.show()

    def visualizar_nucleo(self, ancho, nucleo='rectangular'):
        x = np.linspace(np.min(self.datos) - 1, np.max(self.datos) + 1, 200)
        y = self.estimar_densidad(x, ancho, nucleo)

        plt.plot(x, y, color='darkred',
                label=f'Estimación con núcleo {nucleo}')
        plt.title('Estimación de densidad por núcleos')
        plt.xlabel('Valores')
        plt.ylabel('Densidad')
        plt.legend()
        plt.grid(True)
        plt.show()


class GeneradorDeDatos:
    def __init__(self, n):
        self.n = n

    def generar_normal(self, media, desviacion):
        return np.random.normal(media, desviacion, self.n)

    def generar_uniforme(self, inicio, fin):
        return np.random.uniform(inicio, fin, self.n)

    def generar_t(self, grados_libertad, loc=0, escala=1):
        return np.random.standard_t(grados_libertad, size=self.n) * escala + loc

    def generar_datos_BS(self):
        u = np.random.uniform(size=self.n)
        y = np.zeros(self.n)

        for i in range(self.n):
            if u[i] > 0.5:
                y[i] = np.random.normal(0, 1)
            else:
                for j in range(5):
                    if (j * 0.1) < u[i] <= ((j + 1) * 0.1):
                        y[i] = np.random.normal(j/2 - 1, 0.1)
                        break
        return y

    def densidad_normal(self, x, media, desviacion):
        return norm.pdf(x, media, desviacion)

    def densidad_uniforme(self, x, a, b):
        return uniform.pdf(x, a, b)

    def densidad_t(self, x, gl, loc=0, escala=1):
        return t.pdf((x - loc)/escala, gl)/escala

    def densidad_BS(self, x):
        componente = 0.5 * norm.pdf(x, 0, 1)
        for j in range(5):
            componente += 0.1 * norm.pdf(x, j/2 - 1, 0.1)
        return componente
class Regresion:
    def __init__(self, tipo="lineal"):
        self.tipo_regresion = tipo
        self.variables_independientes = None
        self.variable_dependiente = None
        self.modelo_estimado = None
        self.coeficientes = None
        self.errores_estandar = None

    def estimar_modelo(self, X, Y):
        self.variables_independientes = X
        self.variable_dependiente = Y
        X_con_intercepto = sm.add_constant(X)

        if self.tipo_regresion == "lineal":
            modelo = sm.OLS(Y, X_con_intercepto)
        elif self.tipo_regresion == "logit":
            modelo = sm.Logit(Y, X_con_intercepto)
        else:
            raise ValueError("Tipo de modelo no válido. Usar 'lineal' o 'logit'")

        self.modelo_estimado = modelo.fit()
        self.coeficientes = self.modelo_estimado.params
        self.errores_estandar = self.modelo_estimado.bse

    def realizar_prediccion(self, nuevos_valores_X):
        if self.modelo_estimado is None:
            print("Debe estimar el modelo primero")
            return None

        nuevos_X = sm.add_constant(nuevos_valores_X)
        return self.modelo_estimado.predict(nuevos_X)

class RegresionLineal(Regresion):
    def __init__(self):
        super().__init__(tipo="lineal")

    def graficar_ajuste(self):
        if len(self.variables_independientes.shape) == 1 or self.variables_independientes.shape[1] == 1:
            x_vals = (self.variables_independientes if len(self.variables_independientes.shape) == 1
                     else self.variables_independientes[:, 0])

            plt.figure(figsize=(10,6))
            plt.scatter(x_vals, self.variable_dependiente, alpha=0.7)
            plt.plot(x_vals, self.modelo_estimado.fittedvalues, 'r-', linewidth=2)
            plt.xlabel("Variable Independiente")
            plt.ylabel("Variable Dependiente")
            plt.title("Ajuste del Modelo de Regresión")
            plt.grid(True, linestyle='--', alpha=0.5)
            plt.show()
        else:
            for col in range(self.variables_independientes.shape[1]):
                plt.figure(figsize=(10,6))
                plt.scatter(self.variables_independientes[:, col], self.variable_dependiente, alpha=0.7)
                plt.xlabel(f"Variable Independiente {col+1}")
                plt.ylabel("Variable Dependiente")
                plt.title(f"Relación Variable {col+1} vs Dependiente")
                plt.grid(True, linestyle='--', alpha=0.5)
                plt.show()

    def calcular_coef_correlacion(self):
        if len(self.variables_independientes.shape) == 1 or self.variables_independientes.shape[1] == 1:
            x_data = (self.variables_independientes if len(self.variables_independientes.shape) == 1
                     else self.variables_independientes[:, 0])
            correlacion = np.corrcoef(x_data, self.variable_dependiente)[0, 1]
            print(f"Coeficiente de correlación: {correlacion:.4f}")
        else:
            for col in range(self.variables_independientes.shape[1]):
                correlacion = np.corrcoef(self.variables_independientes[:, col], self.variable_dependiente)[0, 1]
                print(f"Correlación Variable {col+1}: {correlacion:.4f}")

    def analizar_errores(self):
        errores = self.modelo_estimado.resid
        valores_ajustados = self.modelo_estimado.fittedvalues

        # Gráfico Q-Q
        plt.figure(figsize=(10,5))
        stats.probplot(errores, dist="norm", plot=plt)
        plt.title("Gráfico de Probabilidad Normal")
        plt.grid(True, linestyle='--', alpha=0.5)
        plt.show()

        # Gráfico de residuos vs ajustados
        plt.figure(figsize=(10,5))
        plt.scatter(valores_ajustados, errores, alpha=0.7)
        plt.axhline(y=0, color='r', linestyle='-')
        plt.xlabel("Valores Ajustados")
        plt.ylabel("Residuos")
        plt.title("Análisis de Residuos")
        plt.grid(True, linestyle='--', alpha=0.5)
        plt.show()

    def mostrar_resultados(self):
        print("\n=== RESUMEN DEL MODELO ===")
        print("\nCoeficientes estimados:")
        print(self.coeficientes)
        print("\nErrores estándar:")
        print(self.errores_estandar)
        print("\nEstadísticos t:")
        print(self.modelo_estimado.tvalues)
        print("\nValores p:")
        print(self.modelo_estimado.pvalues)
        print(f"R-cuadrado: {self.modelo_estimado.rsquared}")
        print(f"R-cuadrado ajustado: {self.modelo_estimado.rsquared_adj}")

    def calcular_intervalos(self, nuevos_X, nivel_confianza=0.95):
        nuevos_X_const = sm.add_constant(nuevos_X)
        prediccion = self.modelo_estimado.get_prediction(nuevos_X_const)

        alpha = 1 - nivel_confianza
        ic_media = prediccion.conf_int(alpha=alpha, obs=False)
        ic_prediccion = prediccion.conf_int(alpha=alpha, obs=True)

        return {
            "lim_inf_media": ic_media[:, 0],
            "lim_sup_media": ic_media[:, 1],
            "lim_inf_pred": ic_prediccion[:, 0],
            "lim_sup_pred": ic_prediccion[:, 1]
        }

class RegresionLinealSimple(RegresionLineal):
    def __init__(self, x, y):
        """Inicializa un modelo de regresión lineal simple

        Args:
            predictor (array): Variable independiente (1D)
            respuesta (array): Variable dependiente
        """
        super().__init__()
        self.estimar_modelo(x, y)

class RegresionLinealMultiple(RegresionLineal):
    def __init__(self, x, y):
        """Inicializa un modelo de regresión lineal múltiple

        Args:
            predictores (array): Variables independientes (2D array)
            respuesta (array): Variable dependiente
        """
        super().__init__()
        self.estimar_modelo(x, y)

class RegresionLogistica(Regresion):
    def __init__(self):
        """Inicializa un clasificador logístico"""
        super().__init__(tipo="logit")
        self.bondad = {
            'sensibilidad': [],
            'especificidad': [],
            'curva_roc': None
        }

    def prediccion_logistica(self, nuevos_X, punto_corte=0.5):
        """Realiza predicciones categóricas

        Args:
            nuevos_X (array): Datos a predecir
            punto_corte (float): Umbral de clasificación (0-1)

        Returns:
            array: Predicciones binarias (0/1)
        """
        probabilidades = self.realizar_prediccion(nuevos_X)
        return (probabilidades >= punto_corte).astype(int)

    def evaluar_modelo_logistico(self, X_validacion, y_validacion):
        """Evalúa el modelo con datos de validación

        Args:
            X_validacion (array): Variables predictoras
            y_validacion (array): Valores reales
        """
        predicciones = self.prediccion_logistica(X_validacion)

        verdaderos_pos = np.sum((predicciones == 1) & (y_validacion == 1))
        falsos_pos = np.sum((predicciones == 1) & (y_validacion == 0))
        verdaderos_neg = np.sum((predicciones == 0) & (y_validacion == 0))
        falsos_neg = np.sum((predicciones == 0) & (y_validacion == 1))

        error_clasificacion = (falsos_pos + falsos_neg) / len(y_validacion)

        matriz_confusion = pd.DataFrame({
            'Real Positivo': [verdaderos_pos, falsos_neg],
            'Real Negativo': [falsos_pos, verdaderos_neg]
        }, index=['Pred Positivo', 'Pred Negativo'])

        print("Matriz de Confusión:")
        print(matriz_confusion)
        print(f"\nTasa de error: {error_clasificacion:.2%}")

    def calcular_bondad(self, X_test, y_test, umbral=0.5):
        """Calcula sensibilidad y especificidad

        Args:
            X_test (array): Datos de prueba
            y_test (array): Valores reales
            umbral (float): Punto de corte

        Returns:
            tuple: (sensibilidad, especificidad)
        """

        y_pred = self.prediccion_logistica(X_test, umbral)

        a = np.sum((y_pred == 1) & (y_test == 1))
        b = np.sum((y_pred == 0) & (y_test == 1))
        c = np.sum((y_pred == 1) & (y_test == 0))
        d = np.sum((y_pred == 0) & (y_test == 0))

        sensibilidad = a / (a + b) if (a + b) > 0 else 0
        especificidad = d / (d + c) if (d + c) > 0 else 0

        return sensibilidad, especificidad

    def puntos_corte(self, X_test, y_test):
        """Genera puntos para la curva ROC"""
        probabilidades = self.realizar_prediccion(X_test)
        umbrales = np.linspace(0, 1, 100)

        sensibilidad = []
        especificidad = []

        for umbral in umbrales:
            sens, esp = self.calcular_bondad(X_test, y_test, umbral)
            sensibilidad.append(sens)
            especificidad.append(esp)

        self.bondad['sensibilidad'] = sensibilidad
        self.bondad['especificidad'] = especificidad

        return sensibilidad, especificidad

    def graficar_curva_roc(self, X_test, y_test):
        """Grafica la curva ROC"""
        if not self.bondad['sensibilidad']:
            self.puntos_corte(X_test, y_test)

        plt.figure(figsize=(8, 6))
        plt.plot([0, 1], [0, 1], 'k--')
        plt.plot(1 - np.array(self.bondad['especificidad']),
                self.bondad['sensibilidad'],
                'b-', linewidth=2)
        plt.xlabel('1 - Especificidad (cR)')
        plt.ylabel('Sensibilidad (TPR)')
        plt.title('Curva ROC')
        plt.grid(True)
        plt.show()

    def calcular_auc(self, X_test, y_test):
        """Calcula el área bajo la curva ROC"""
        if not self.bondad['sensibilidad']:
            self.puntos_corte(X_test, y_test)

        return auc(1 - np.array(self.bondad['especificidad']),
                 np.array(self.bondad['sensibilidad']))